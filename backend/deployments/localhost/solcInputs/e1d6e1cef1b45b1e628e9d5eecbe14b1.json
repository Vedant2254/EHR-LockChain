{
  "language": "Solidity",
  "sources": {
    "contracts/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary AddressArrayUtils {\n    function indexOf(address[] memory arr, address key) internal pure returns (int256) {\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i] == key) return int256(i);\n        }\n        return -1;\n    }\n\n    function contains(address[] memory arr, address key) internal pure returns (bool) {\n        return indexOf(arr, key) != -1;\n    }\n\n    function remove(address[] storage arr, address key) internal returns (bool) {\n        int256 i = indexOf(arr, key);\n\n        if (i == -1) return false;\n\n        address[] memory temp = arr;\n        arr[uint256(i)] = temp[temp.length - 1];\n        arr.pop();\n\n        return true;\n    }\n}\n"
    },
    "contracts/AddToBoolMapping.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary AddToBoolMapping {\n    // mapping address => bool\n    struct Map {\n        address[] keys;\n        mapping(address => bool) values;\n        mapping(address => uint256) indexOf;\n    }\n\n    function get(Map storage map, address key) internal view returns (bool) {\n        return map.values[key];\n    }\n\n    function getKeys(Map storage map) internal view returns (address[] memory) {\n        return map.keys;\n    }\n\n    function getKeyAtIndex(Map storage map, uint256 index) internal view returns (address) {\n        return map.keys[index];\n    }\n\n    function size(Map storage map) internal view returns (uint256) {\n        return map.keys.length;\n    }\n\n    function set(Map storage map, address key) internal {\n        if (map.values[key]) return;\n\n        // add address => true mapping to values\n        map.values[key] = true;\n\n        // add index of address to indexOf mapping\n        map.indexOf[key] = map.keys.length;\n\n        // add address to keys\n        map.keys.push(key);\n    }\n\n    function unset(Map storage map, address key) internal {\n        if (!map.values[key]) return;\n\n        // remove from values\n        delete map.values[key];\n\n        // important backups\n        uint256 index = map.indexOf[key];\n        uint256 lastIndex = map.keys.length - 1;\n        address lastKey = map.keys[lastIndex];\n\n        // update indexOf last element\n        map.indexOf[lastKey] = index;\n        delete map.indexOf[key];\n\n        // remove from keys\n        map.keys[index] = lastKey;\n        map.keys.pop();\n    }\n}\n"
    },
    "contracts/AddToStrMapping.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nlibrary AddToStrMapping {\n    // mapping address => string\n    struct Map {\n        address[] keys;\n        mapping(address => string) values;\n        mapping(address => uint256) indexOf;\n        mapping(address => bool) inserted;\n    }\n\n    function get(Map storage map, address key) internal view returns (string memory) {\n        return map.values[key];\n    }\n\n    function getKeys(Map storage map) internal view returns (address[] memory) {\n        return map.keys;\n    }\n\n    function getKeyAtIndex(Map storage map, uint256 index) internal view returns (address) {\n        return map.keys[index];\n    }\n\n    function size(Map storage map) internal view returns (uint256) {\n        return map.keys.length;\n    }\n\n    function set(Map storage map, address key, string memory val) internal {\n        if (!map.inserted[key]) {\n            // add index of address to indexOf mapping\n            map.indexOf[key] = map.keys.length;\n\n            // make value of address in inserted to true\n            map.inserted[key] = true;\n\n            // add address to keys\n            map.keys.push(key);\n        }\n\n        // add address => true mapping to values\n        map.values[key] = val;\n    }\n\n    function remove(Map storage map, address key) internal {\n        if (!map.inserted[key]) return;\n\n        // remove from values\n        delete map.values[key];\n        delete map.inserted[key];\n\n        // important backups\n        uint256 index = map.indexOf[key];\n        uint256 lastIndex = map.keys.length - 1;\n        address lastKey = map.keys[lastIndex];\n\n        // update indexOf last element\n        map.indexOf[lastKey] = index;\n        delete map.indexOf[key];\n\n        // remove from keys\n        map.keys[index] = lastKey;\n        map.keys.pop();\n    }\n}\n"
    },
    "contracts/Contract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"./Roles.sol\";\nimport \"./AddressArrayUtils.sol\";\nimport \"./AddToBoolMapping.sol\";\n\nerror Contract__NotAdmin();\nerror Contract__NotDoctor();\nerror Contract__NotPatient();\nerror Contract__PendingDoctorApproval();\nerror Contract__DoctorPublicKeyMissing();\n\ncontract Contract {\n    // using methods of Roles for Role struct in Roles\n    using Roles for Roles.Role;\n    using AddToBoolMapping for AddToBoolMapping.Map;\n    using AddressArrayUtils for address[];\n\n    struct MedicalRecord {\n        address editor;\n        address[] viewers;\n        string key_data_hash;\n    }\n\n    struct Admin {\n        address user;\n        AddToBoolMapping.Map pending_doctors;\n    }\n\n    struct Patients {\n        Roles.Role users;\n        mapping(address => MedicalRecord) records;\n    }\n\n    struct Doctors {\n        Roles.Role users;\n        mapping(address => string) public_keys;\n        mapping(address => AddToBoolMapping.Map) docToPatAccess;\n    }\n\n    // defining roles - contains hashes\n    Admin private admin;\n    Doctors private doctors;\n    Patients private patients;\n\n    // Initializing admin\n    constructor() {\n        admin.user = msg.sender;\n    }\n\n    // Admin methods\n    function getAdmin() public view returns (address) {\n        return admin.user;\n    }\n\n    function isAdmin(address _address) public view returns (bool) {\n        if (admin.user == _address) return true;\n        return false;\n    }\n\n    // Doctor methods\n    function isDoctor(address _address) public view returns (bool) {\n        if (!doctors.users.has(_address)) return false;\n        if (admin.pending_doctors.get(_address)) return false;\n        if (bytes(doctors.public_keys[_address]).length == 0) return false;\n        return true;\n    }\n\n    function addDoctor(string memory _hash) public {\n        if (bytes(_hash).length == 0) revert(\"Contract: Empty hash is not allowed!\");\n        doctors.users.add(msg.sender, _hash);\n        admin.pending_doctors.set(msg.sender);\n    }\n\n    function approveDoctor(address _address) public onlyAdmin {\n        if (isDoctor(_address)) return;\n        if (!doctors.users.has(_address)) return;\n        admin.pending_doctors.unset(_address);\n    }\n\n    function confirmAddDr(string memory _public_key) public {\n        if (bytes(_public_key).length == 0) revert(\"Contract: Empty public key is not allowed!\");\n        if (!doctors.users.has(msg.sender)) revert Contract__NotDoctor();\n        if (admin.pending_doctors.get(msg.sender)) revert Contract__PendingDoctorApproval();\n        doctors.public_keys[msg.sender] = _public_key;\n    }\n\n    function setDrHash(string memory _hash) public onlyDoctor {\n        if (bytes(_hash).length == 0) revert(\"Contract: Empty hash is not allowed!\");\n        doctors.users.setHash(msg.sender, _hash);\n    }\n\n    function getDrHash(address _address) public view returns (string memory) {\n        if (!isDoctor(_address)) revert Contract__NotDoctor();\n        return doctors.users.getHash(_address);\n    }\n\n    function getDrPubKey(address _address) public view returns (string memory) {\n        return doctors.public_keys[_address];\n    }\n\n    function getAllDrs() public view returns (address[] memory) {\n        return doctors.users.getMembers();\n    }\n\n    function getDocPats() public view onlyDoctor returns (address[] memory) {\n        return doctors.docToPatAccess[msg.sender].keys;\n    }\n\n    // Patient methods\n    function isPatient(address _address) public view returns (bool) {\n        return patients.users.has(_address);\n    }\n\n    function addPatient(string memory _hash, string memory _key_data_hash) public {\n        if (bytes(_hash).length == 0) revert(\"Contract: Empty hash is not allowed\");\n        patients.users.add(msg.sender, _hash);\n        patients.records[msg.sender].key_data_hash = _key_data_hash;\n    }\n\n    function setPatGeneralHash(string memory _hash) public onlyPatient {\n        patients.users.setHash(msg.sender, _hash);\n    }\n\n    function getPatGeneralHash(address _address) public view returns (string memory) {\n        if (!isPatient(_address)) revert Contract__NotPatient();\n\n        if (\n            msg.sender == _address ||\n            patients.records[_address].editor == msg.sender ||\n            patients.records[_address].viewers.indexOf(msg.sender) != -1\n        ) return patients.users.getHash(_address);\n\n        revert(\"Not Allowed\");\n    }\n\n    function setPatRecordHash(address _address, string memory _hash) public {\n        if (!isPatient(_address)) revert Contract__NotPatient();\n        if (!(msg.sender == _address || patients.records[_address].editor == msg.sender))\n            revert(\"Not Allowed\");\n        patients.records[_address].key_data_hash = _hash;\n    }\n\n    function getPatRecordHash(address _address) public view returns (string memory) {\n        if (!isPatient(_address)) revert Contract__NotPatient();\n\n        if (\n            msg.sender == _address ||\n            patients.records[_address].editor == msg.sender ||\n            patients.records[_address].viewers.indexOf(msg.sender) != -1\n        ) return patients.records[_address].key_data_hash;\n\n        revert(\"Not Allowed\");\n    }\n\n    function getAllPats() public view returns (address[] memory) {\n        return patients.users.getMembers();\n    }\n\n    function changeEditorAccess(address _address) public onlyPatient {\n        // pending update - when user changes access, symmetric key S must be changed\n        if (!isDoctor(_address)) revert Contract__NotDoctor();\n\n        // remove old editor access\n        address old_editor = patients.records[msg.sender].editor;\n        doctors.docToPatAccess[old_editor].unset(msg.sender);\n\n        // add new editor access\n        patients.records[msg.sender].editor = _address;\n        doctors.docToPatAccess[_address].set(msg.sender);\n    }\n\n    function removeEditorAccess() public onlyPatient {\n        address old_editor = patients.records[msg.sender].editor;\n        patients.records[msg.sender].editor = address(0);\n        doctors.docToPatAccess[old_editor].unset(msg.sender);\n    }\n\n    function getPatDr() public view onlyPatient returns (address) {\n        return patients.records[msg.sender].editor;\n    }\n\n    function grantViewerAccess(address _address) public onlyPatient {\n        if (!isDoctor(_address)) revert Contract__NotDoctor();\n\n        if (!patients.records[msg.sender].viewers.contains(_address)) {\n            patients.records[msg.sender].viewers.push(_address);\n        }\n    }\n\n    function revokeViewerAccess(address _address) public onlyPatient {\n        // pending update - when user revokes access, symmetric key S must be changed\n        if (!isDoctor(_address)) revert Contract__NotDoctor();\n\n        patients.records[msg.sender].viewers.remove(_address);\n    }\n\n    function getPatViewers() public view onlyPatient returns (address[] memory) {\n        return patients.records[msg.sender].viewers;\n    }\n\n    // modifiers\n    modifier onlyAdmin() {\n        if (!isAdmin(msg.sender)) revert Contract__NotAdmin();\n        _;\n    }\n\n    modifier onlyDoctor() {\n        if (!doctors.users.has(msg.sender)) revert Contract__NotDoctor();\n        if (admin.pending_doctors.get(msg.sender)) revert Contract__PendingDoctorApproval();\n        if (bytes(doctors.public_keys[msg.sender]).length == 0)\n            revert Contract__DoctorPublicKeyMissing();\n        _;\n    }\n\n    modifier onlyPatient() {\n        if (!isPatient(msg.sender)) revert Contract__NotPatient();\n        _;\n    }\n}\n"
    },
    "contracts/Roles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport \"./AddToStrMapping.sol\";\n\nlibrary Roles {\n    using AddToStrMapping for AddToStrMapping.Map;\n\n    // This is to keep track of roles\n    // Reduces searching cost\n    struct Role {\n        AddToStrMapping.Map bearer;\n    }\n\n    function add(Role storage role, address account, string memory hash) internal {\n        require(!has(role, account), \"Roles: account already has role\");\n        role.bearer.set(account, hash);\n    }\n\n    function remove(Role storage role, address account) internal {\n        require(has(role, account), \"Roles: account does not have role\");\n        role.bearer.remove(account);\n    }\n\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0), \"Roles: account is the zero address\");\n        return bytes(role.bearer.get(account)).length != 0;\n    }\n\n    function setHash(Role storage role, address account, string memory _hash) internal {\n        role.bearer.set(account, _hash);\n    }\n\n    function getHash(Role storage role, address account) internal view returns (string memory) {\n        return role.bearer.get(account);\n    }\n\n    function getMembers(Role storage role) internal view returns (address[] memory) {\n        return role.bearer.keys;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}